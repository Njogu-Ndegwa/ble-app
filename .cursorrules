# Cursor Rules for OVES Mobile App

This document defines the coding standards, patterns, and conventions that MUST be followed when working on this codebase. These rules ensure consistency, maintainability, and proper architecture.

---

## ğŸš¨ CRITICAL RULES

### 1. Currency Handling - NEVER Hardcode Currencies
**Currency symbols MUST come from backend data, NEVER be hardcoded.**

```typescript
// âŒ WRONG - Never do this
<PaymentCollection currencySymbol="KES" amount={100} />
toast.error(`Payment insufficient. Customer paid KES ${amount}`);

// âœ… CORRECT - Always use dynamic currency from data
<PaymentCollection currencySymbol={swapData.currencySymbol} amount={100} />
toast.error(`Payment insufficient. Customer paid ${swapData.currencySymbol} ${amount}`);
```

Currency should flow from:
- Customer subscription data
- Station/location configuration
- Service response from backend
- Plan/package data

Only use `PAYMENT.defaultCurrency` from `@/lib/constants` as a last-resort fallback.

### 2. Internationalization - ALWAYS Add Translation Keys
**When adding new user-facing text, you MUST add translation keys to ALL translation files.**

Translation files are located in `/src/i18n/messages/`:
- `en.json` - English
- `fr.json` - French
- `zh.json` - Chinese

```typescript
// âŒ WRONG - Hardcoded strings
<span>Connected</span>
toast.error('Connection failed');

// âŒ WRONG - Using translation key that doesn't exist (shows as "common.Connected")
<span>{t('common.Connected')}</span>  // Key doesn't exist in translation files!

// âœ… CORRECT - Use i18n with existing keys, with fallback
<span>{t('common.connected') || 'Connected'}</span>
toast.error(t('attendant.connectionFailed') || 'Connection failed');
```

**When creating new components or adding new text:**
1. Use the `t()` function from `useI18n()` hook
2. Add the translation key to ALL three translation files (en.json, fr.json, zh.json)
3. Follow the naming convention: `namespace.keyName` (e.g., `attendant.scanCustomer`, `common.retry`)
4. Always provide a fallback string with `|| 'Fallback'` for safety

**Common namespaces:**
- `common.*` - Shared across the app (e.g., `common.retry`, `common.back`, `common.connected`)
- `attendant.*` - Attendant workflow
- `sales.*` - Sales/customer workflow
- `ble.*` - Bluetooth-related messages
- `auth.*` - Authentication messages

### 3. Use the Design System
All UI must use the established design system. Never create ad-hoc styles.

```typescript
// âŒ WRONG - Ad-hoc styling
<div style={{ fontSize: '14px', color: '#00e5e5', padding: '16px' }}>

// âœ… CORRECT - Use design tokens and components
import { colors, spacing, fontSize } from '@/styles';
<div style={{ fontSize: fontSize.base, color: colors.brand.primary, padding: spacing[4] }}>

// âœ… EVEN BETTER - Use UI components
import { Card, Badge, Button } from '@/components/ui';
<Card><Badge variant="success">Active</Badge></Card>
```

---

## ğŸ“ Project Structure

```
src/
â”œâ”€â”€ app/                    # Next.js app router pages
â”‚   â””â”€â”€ (mobile)/          # Mobile-specific routes
â”‚       â”œâ”€â”€ attendant/     # Attendant workflow
â”‚       â”œâ”€â”€ customers/     # Sales/customer workflow  
â”‚       â””â”€â”€ rider/         # Rider app
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ ui/                # Pure UI components (no business logic)
â”‚   â”‚   â”œâ”€â”€ Avatar.tsx
â”‚   â”‚   â”œâ”€â”€ Badge.tsx
â”‚   â”‚   â”œâ”€â”€ Button.tsx
â”‚   â”‚   â”œâ”€â”€ Card.tsx
â”‚   â”‚   â”œâ”€â”€ Form.tsx
â”‚   â”‚   â”œâ”€â”€ Icons.tsx
â”‚   â”‚   â”œâ”€â”€ Layout.tsx
â”‚   â”‚   â”œâ”€â”€ Progress.tsx
â”‚   â”‚   â”œâ”€â”€ State.tsx
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â””â”€â”€ shared/            # Reusable business components
â”‚       â”œâ”€â”€ BatteryScanBind.tsx
â”‚       â”œâ”€â”€ PaymentCollection.tsx
â”‚       â”œâ”€â”€ SuccessReceipt.tsx
â”‚       â””â”€â”€ index.ts
â”œâ”€â”€ lib/                   # Utilities and helpers
â”‚   â”œâ”€â”€ constants.ts       # App-wide constants
â”‚   â”œâ”€â”€ hooks.ts          # Custom React hooks
â”‚   â”œâ”€â”€ types.ts          # Domain types
â”‚   â”œâ”€â”€ utils.ts          # Utility functions
â”‚   â”œâ”€â”€ odoo-api.ts       # Odoo REST API client
â”‚   â””â”€â”€ services/         # Service layer
â”‚       â”œâ”€â”€ mqtt-service.ts  # MQTT messaging
â”‚       â”œâ”€â”€ hooks/           # Service React hooks
â”‚       â”‚   â””â”€â”€ useMqtt.ts
â”‚       â””â”€â”€ index.ts
â”œâ”€â”€ styles/               # Design system
â”‚   â”œâ”€â”€ tokens.ts         # Design tokens (TypeScript)
â”‚   â”œâ”€â”€ design-system.css # CSS variables
â”‚   â””â”€â”€ index.ts
â””â”€â”€ i18n/                 # Internationalization
```

---

## ğŸ§© Component Guidelines

### UI Components (`/components/ui/`)
- Pure presentational components
- No business logic or API calls
- Accept data via props
- Use design tokens for styling
- Export from `index.ts`

```typescript
// Good UI component
export function Badge({ children, variant = 'default' }: BadgeProps) {
  return <span className={`badge badge-${variant}`}>{children}</span>;
}
```

### Shared Components (`/components/shared/`)
- Reusable business logic components
- Can contain state and side effects
- Used across multiple workflows
- Examples: BatteryScanBind, PaymentCollection

### Workflow Components (`/app/(mobile)/*/components/`)
- Workflow-specific components
- Compose UI and shared components
- Handle workflow-specific state

---

## ğŸ“ TypeScript Conventions

### Always Define Types
```typescript
// âŒ WRONG
const customer = { name: 'John', phone: '123' };

// âœ… CORRECT
interface Customer {
  name: string;
  phone: string;
  currencySymbol: string;  // Always include currency!
}
const customer: Customer = { name: 'John', phone: '123', currencySymbol: 'KES' };
```

### Use Domain Types from `/lib/types.ts`
```typescript
import type { Customer, Battery, Transaction, SwapData } from '@/lib/types';
```

### Props Interfaces
```typescript
interface ComponentProps {
  // Required props first
  data: SwapData;
  onComplete: (result: Transaction) => void;
  
  // Optional props with defaults
  isLoading?: boolean;
  variant?: 'primary' | 'secondary';
}
```

---

## ğŸ¨ Styling Rules

### 1. Use Design Tokens
```typescript
import { colors, spacing, fontSize, fontWeight } from '@/styles';

// In components
style={{ 
  color: colors.text.primary,
  padding: spacing[4],
  fontSize: fontSize.base 
}}
```

### 2. Use Tailwind with CSS Variables
```typescript
// Tailwind classes use our design system
<div className="bg-primary text-white p-4 rounded-lg" />
```

### 3. Never Use Magic Numbers
```typescript
// âŒ WRONG
style={{ padding: '16px', borderRadius: '8px' }}

// âœ… CORRECT
style={{ padding: spacing[4], borderRadius: radius.lg }}
// or
className="p-4 rounded-lg"
```

---

## ğŸ”„ State Management

### Use Custom Hooks from `/lib/hooks.ts`
```typescript
import { useLocalStorage, useDebounce, useAsync } from '@/lib/hooks';

// Persistent state
const [user, setUser] = useLocalStorage('user', null);

// Debounced values
const debouncedSearch = useDebounce(searchTerm, 300);

// Async operations
const { data, loading, error, execute } = useAsync(fetchCustomer);
```

### Use Constants from `/lib/constants.ts`
```typescript
import { PAYMENT, BLE, MQTT, STATUS } from '@/lib/constants';

// Good
if (amount < PAYMENT.minimumAmount[currency]) { ... }

// Bad - magic numbers
if (amount < 10) { ... }
```

---

## ğŸ”Œ Services & API Layer

### MQTT - Use the Service Layer
**Never write raw MQTT operations in components. Always use the service or hooks.**

```typescript
// âŒ WRONG - Raw bridge calls in components
bridge.callHandler('mqttPublishMsg', { topic, message }, (resp) => { ... });
bridge.registerHandler('mqttMessageReceived', (data) => { ... });

// âœ… CORRECT - Use the MQTT hook
import { useMqtt } from '@/lib/services/hooks';

function MyComponent() {
  const { publish, subscribe, isReady } = useMqtt();
  
  useEffect(() => {
    if (!isReady) return;
    return subscribe('abs/response/customer/+', handleMessage);
  }, [isReady, subscribe]);
  
  const handleSend = async () => {
    await publish('abs/request/customer', { action: 'lookup' });
  };
}
```

### API Calls - Use Typed Functions
**Never make raw fetch calls. Use the typed API functions.**

```typescript
// âŒ WRONG - Raw fetch in components
const response = await fetch('/api/payments/confirm', {
  method: 'POST',
  body: JSON.stringify({ order_id, receipt }),
});

// âœ… CORRECT - Use typed API functions
import { confirmPaymentManual, createPaymentRequest } from '@/lib/odoo-api';

const paymentRequest = await createPaymentRequest({
  subscription_code: 'SUB-001',
  amount_required: 500,
  description: 'Swap payment',
}, authToken);

const confirmation = await confirmPaymentManual({
  order_id: paymentRequest.payment_request.sale_order.id,
  receipt: 'MPESA_RECEIPT_123',
}, authToken);
```

### Service Patterns

1. **MQTT Request/Response Pattern**:
```typescript
const { publishAndWait } = useMqtt();

const result = await publishAndWait(
  'abs/request/customer',           // Publish to
  { action: 'lookup', code: '123' }, // Payload
  'abs/response/customer/+',         // Subscribe for response
  30000                              // Timeout
);
```

2. **API Error Handling**:
```typescript
try {
  const result = await createPaymentRequest(payload, token);
  if (!result.success) {
    // Handle business logic error
    if (result.existing_request) {
      // Handle existing request case
    }
  }
} catch (error) {
  // Handle network/system error
  toast.error('Connection failed');
}
```

---

## ğŸŒ Internationalization

Always use the i18n system for user-facing text:

```typescript
import { useI18n } from '@/i18n';

function Component() {
  const { t } = useI18n();
  
  return <h1>{t('attendant.scanCustomer')}</h1>;
}
```

### Adding New Translation Keys

**CRITICAL: When you add new text, you MUST add the translation key to ALL translation files!**

1. Open `/src/i18n/messages/en.json`, `/src/i18n/messages/fr.json`, and `/src/i18n/messages/zh.json`
2. Add the key with appropriate translations to each file
3. Use the established naming patterns

```json
// In en.json
{
  "attendant.newFeature": "New Feature Text",
  "common.newAction": "New Action"
}

// In fr.json  
{
  "attendant.newFeature": "Texte de nouvelle fonctionnalitÃ©",
  "common.newAction": "Nouvelle action"
}

// In zh.json
{
  "attendant.newFeature": "æ–°åŠŸèƒ½æ–‡æœ¬",
  "common.newAction": "æ–°æ“ä½œ"
}
```

### Translation Key Naming Conventions

- **Namespace prefixes**: Use `common.`, `attendant.`, `sales.`, `ble.`, `auth.`, etc.
- **camelCase keys**: Use camelCase after the namespace (e.g., `attendant.scanCustomer`)
- **Descriptive names**: Keys should describe the content (e.g., `common.connectionFailed` not `common.error1`)
- **Group related keys**: Keep related keys together in the JSON files

### Fallback Pattern

Always provide a fallback for safety in case translation is missing:

```typescript
// Good - with fallback
{t('attendant.newMessage') || 'Default message'}

// Also good for complex fallbacks
const message = t('attendant.customMessage') || `Fallback with ${variable}`;
```

---

## ğŸ”Œ API & Data

### Data Should Include Currency
When defining or receiving data structures, always include currency:

```typescript
interface SwapData {
  cost: number;
  rate: number;
  currencySymbol: string;  // REQUIRED
}

interface PricingData {
  amount: number;
  currencySymbol: string;  // REQUIRED
}
```

### API Response Types
```typescript
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}
```

---

## âœ… Code Review Checklist

Before submitting code, verify:

- [ ] No hardcoded currency symbols (KES, USD, etc.)
- [ ] Using UI components from `/components/ui/` where applicable
- [ ] Using design tokens, not magic numbers
- [ ] Types are properly defined
- [ ] Using i18n for user-facing strings
- [ ] **All new translation keys added to ALL translation files (en.json, fr.json, zh.json)**
- [ ] Constants from `/lib/constants.ts` for configuration
- [ ] Custom hooks from `/lib/hooks.ts` for common patterns
- [ ] Proper error handling with user-friendly messages
- [ ] Currency flows from backend data

---

## ğŸš« Anti-Patterns to Avoid

1. **Hardcoded currencies** - Always dynamic
2. **Inline styles with magic values** - Use design tokens
3. **Duplicate code** - Extract to shared components/hooks
4. **Any types** - Always define proper types
5. **Direct DOM manipulation** - Use React patterns
6. **Console.log in production** - Use proper logging
7. **Ignoring TypeScript errors** - Fix them properly
8. **Missing translation keys** - Always add new keys to ALL translation files (en, fr, zh)
9. **Hardcoded user-facing strings** - Always use `t()` from `useI18n()`

---

## ğŸ“š Key Files to Reference

When making changes, consult these files:

- `/src/lib/constants.ts` - Application constants (PAYMENT, MQTT, BLE, etc.)
- `/src/lib/types.ts` - Domain types
- `/src/lib/hooks.ts` - Custom hooks
- `/src/lib/utils.ts` - Utility functions
- `/src/lib/odoo-api.ts` - Odoo REST API (payments, subscriptions, customers)
- `/src/lib/services/mqtt-service.ts` - MQTT messaging service
- `/src/lib/services/hooks/useMqtt.ts` - MQTT React hook
- `/src/styles/tokens.ts` - Design tokens
- `/src/components/ui/index.ts` - UI components
- `/src/components/shared/index.ts` - Shared business components
- `/src/i18n/messages/en.json` - English translations
- `/src/i18n/messages/fr.json` - French translations
- `/src/i18n/messages/zh.json` - Chinese translations

---

## ğŸ”§ Common Tasks

### Adding a New Currency Display
```typescript
// Get currency from data, with fallback
const currency = data.currencySymbol || PAYMENT.defaultCurrency;
return `${currency} ${amount.toFixed(2)}`;
```

### Creating a New Component
1. Decide: UI (`/components/ui/`) or Shared (`/components/shared/`)
2. Define TypeScript interface for props
3. Use design tokens for styling
4. Export from the appropriate `index.ts`
5. Add to documentation if significant

### Adding a New Page/Route
1. Create in `/app/(mobile)/[feature]/`
2. Use existing UI components
3. Follow the established layout patterns
4. Include proper types and i18n

### Adding MQTT Communication
1. Use the `useMqtt` hook in your component
2. Subscribe in `useEffect` with proper cleanup
3. Use `publishAndWait` for request/response patterns
4. Handle loading/error states

```typescript
import { useMqtt } from '@/lib/services/hooks';

function MyComponent() {
  const { publish, subscribe, publishAndWait, isReady } = useMqtt();
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);

  // Subscribe to responses
  useEffect(() => {
    if (!isReady) return;
    return subscribe('my/response/topic', (message) => {
      setData(message.payload);
    });
  }, [isReady, subscribe]);

  // Request with response
  const fetchData = async () => {
    setLoading(true);
    const result = await publishAndWait(
      'my/request/topic',
      { action: 'fetch' },
      'my/response/topic',
      30000
    );
    if (result.success) {
      setData(result.data);
    }
    setLoading(false);
  };
}
```

### Adding a New API Endpoint
1. Add types in `/lib/odoo-api.ts`
2. Create the typed function
3. Handle response normalization
4. Include proper error handling

```typescript
// In odoo-api.ts
export interface MyNewPayload { ... }
export interface MyNewResponse { ... }

export async function myNewApiCall(
  payload: MyNewPayload,
  authToken?: string
): Promise<OdooApiResponse<MyNewResponse>> {
  const headers: HeadersInit = {};
  if (authToken) {
    headers['Authorization'] = `Bearer ${authToken}`;
  }
  
  return apiRequest<MyNewResponse>('/api/my-endpoint', {
    method: 'POST',
    body: JSON.stringify(payload),
    headers,
  });
}
```

### Adding New Translation Keys
When adding any new user-facing text:

1. **Identify the namespace** - Use existing ones like `common.`, `attendant.`, `sales.`, or create a new one if needed
2. **Add to ALL translation files** - en.json, fr.json, zh.json
3. **Use in component** with fallback

```typescript
// Step 1: Add to /src/i18n/messages/en.json
{
  "myFeature.newMessage": "This is a new message"
}

// Step 2: Add to /src/i18n/messages/fr.json
{
  "myFeature.newMessage": "Ceci est un nouveau message"
}

// Step 3: Add to /src/i18n/messages/zh.json
{
  "myFeature.newMessage": "è¿™æ˜¯ä¸€æ¡æ–°æ¶ˆæ¯"
}

// Step 4: Use in component
import { useI18n } from '@/i18n';

function MyComponent() {
  const { t } = useI18n();
  return <span>{t('myFeature.newMessage') || 'This is a new message'}</span>;
}
```

**Common translation keys to use:**
- `common.connected` - "Connected"
- `common.failed` - "Failed"
- `common.retry` - "Retry"
- `common.processing` - "Processing..."
- `common.back` - "Back"
- `common.close` - "Close"
- `common.tryAgain` - "Try Again"
